package io.github.quafadas.scautable

import io.github.quafadas.table.*
import munit.FunSuite

class RuntimeCsvSuite extends FunSuite:

  test("fromTyped creates a function that can read CSV from runtime path") {
    val csvReader = CSV.fromTyped[("col1", "col2", "col3"), (String, String, String)]

    // Get the resource path at runtime
    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("simple.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).col1, "1")
    assertEquals(rows(0).col2, "2")
    assertEquals(rows(0).col3, "7")
    assertEquals(rows(1).col1, "3")
    assertEquals(rows(1).col2, "4")
    assertEquals(rows(1).col3, "8")
    assertEquals(rows(2).col1, "5")
    assertEquals(rows(2).col2, "6")
    assertEquals(rows(2).col3, "9")
  }

  test("fromTyped with typed columns reads and decodes CSV correctly") {
    val csvReader = CSV.fromTyped[("col1", "col2", "col3"), (Int, Int, Int)]

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("simple.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).col1, 1)
    assertEquals(rows(0).col2, 2)
    assertEquals(rows(0).col3, 7)
    assertEquals(rows(1).col1, 3)
    assertEquals(rows(1).col2, 4)
    assertEquals(rows(1).col3, 8)
    assertEquals(rows(2).col1, 5)
    assertEquals(rows(2).col2, 6)
    assertEquals(rows(2).col3, 9)
  }

  test("fromTyped with mixed types reads and decodes CSV correctly") {
    val csvReader = CSV.fromTyped[("col1", "col2", "col3"), (Int, String, Double)]

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("simple.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).col1, 1)
    assertEquals(rows(0).col2, "2")
    assertEquals(rows(0).col3, 7.0)
  }

  test("fromTyped with HeaderOptions.AutoGenerated creates headers based on column index") {
    val csvReader = CSV.fromTyped[("col_0", "col_1", "col_2"), (String, String, String)](HeaderOptions.AutoGenerated)

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("data_without_headers.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).col_0, "Alice")
    assertEquals(rows(0).col_1, "25")
    assertEquals(rows(0).col_2, "Engineer")
    assertEquals(rows(1).col_0, "Bob")
    assertEquals(rows(1).col_1, "30")
    assertEquals(rows(1).col_2, "Designer")
    assertEquals(rows(2).col_0, "Charlie")
    assertEquals(rows(2).col_1, "22")
    assertEquals(rows(2).col_2, "Student")
  }

  test("fromTyped with HeaderOptions.Manual uses explicit headers") {
    val csvReader = CSV.fromTyped[("name", "age", "profession"), (String, Int, String)](HeaderOptions.Manual("name", "age", "profession"))

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("data_without_headers.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).name, "Alice")
    assertEquals(rows(0).age, 25)
    assertEquals(rows(0).profession, "Engineer")
  }

  test("fromTyped with HeaderOptions.FromRows merges multi-line headers") {
    val csvReader = CSV.fromTyped[("Name First", "Age Years"), (String, String)](HeaderOptions.FromRows(merge = 2, dropFirst = 1))

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("multiline_headers_dropline.csv").getPath)

    val csv = csvReader(resourcePath)
    val rows = csv.toArray

    assertEquals(rows.length, 2)
    assertEquals(rows(0).`Name First`, "Alice")
    assertEquals(rows(0).`Age Years`, "30")
    assertEquals(rows(1).`Name First`, "Bob")
    assertEquals(rows(1).`Age Years`, "24")
  }

  test("fromTyped can be reused for multiple files with same schema") {
    val csvReader = CSV.fromTyped[("col1", "col2", "col3"), (String, String, String)]

    val resourcePath = os.Path(this.getClass.getClassLoader.getResource("simple.csv").getPath)

    // Read the same file twice using the same reader function
    val csv1 = csvReader(resourcePath)
    val rows1 = csv1.toArray

    val csv2 = csvReader(resourcePath)
    val rows2 = csv2.toArray

    assertEquals(rows1.length, rows2.length)
    assertEquals(rows1(0).col1, rows2(0).col1)
    assertEquals(rows1(0).col2, rows2(0).col2)
    assertEquals(rows1(0).col3, rows2(0).col3)
  }

  test("fromTyped with runtime-determined path from variable") {
    val csvReader = CSV.fromTyped[("col1", "col2", "col3"), (Int, Int, Int)]

    // Simulate runtime path determination
    val basePath = os.Path(this.getClass.getClassLoader.getResource("simple.csv").getPath.dropRight("simple.csv".length))
    val fileName = "simple.csv"
    val runtimePath = basePath / fileName

    val csv = csvReader(runtimePath)
    val rows = csv.toArray

    assertEquals(rows.length, 3)
    assertEquals(rows(0).col1, 1)
  }

end RuntimeCsvSuite
