package io.github.quafadas.scautable
import scala.NamedTuple.*
import scala.annotation.nowarn

import io.github.quafadas.table.*

class CSVSuite extends munit.FunSuite:

  test("csv from resource compiles and typechecks") {
    @nowarn val csv: CsvIterator[("col1", "col2", "col3"), (Int, Int, Int)] = CSV.resource("simple.csv", CsvOpts.default)

    @nowarn val titanic: CsvIterator[
      ("PassengerId", "Survived", "Pclass", "Name", "Sex", "Age", "SibSp", "Parch", "Ticket", "Fare", "Cabin", "Embarked"),
      (String, String, String, String, String, String, String, String, String, String, String, String)
    ] =
      CSV.resource("titanic.csv", TypeInferrer.StringType)
    // val wide = CSV.resource("wide.csv")
  }

  test("delimiter config") {
    @nowarn val csv: CsvIterator[("col1", "col2", "col3"), (Int, Int, Int)] = CSV.resource("simple_semicolon.csv", CsvOpts(HeaderOptions.Default, TypeInferrer.FromAllRows, ';'))
    @nowarn val csv1: CsvIterator[("col1", "col2", "col3"), (Int, Int, Int)] = CSV.resource("simple.csv", CsvOpts(HeaderOptions.Default, TypeInferrer.FromAllRows))

    @nowarn val csv2: CsvIterator[("col1", "col2", "col3"), (Int, Int, Int)] = CSV.resource("simple_semicolon.csv", CsvOpts(typeInferrer = TypeInferrer.FromAllRows, delimiter = ';'))

    @nowarn val csv3: CsvIterator[("col_0", "col_1", "col_2"), (String, String, String)] =
      CSV.resource("simple_semicolon.csv", CsvOpts(headerOptions = HeaderOptions.AutoGenerated, delimiter = ';'))

    @nowarn val csv4: CsvIterator[("col1", "col2", "col3"), (Int, Int, Int)] = CSV.resource("simple_semicolon.csv", CsvOpts(delimiter = ';'))

  }

  test("delimiter config with merged headers") {
    val csv: CsvIterator[("col1 1", "col2 2", "col3 7"), (Int, Int, Int)] = CSV.resource(
      "simple_semicolon.csv",
      CsvOpts(HeaderOptions.FromRows(merge = 2, dropFirst = 0), TypeInferrer.FromAllRows, ';')
    )
    assertEquals(csv.toSeq.length, 2)

    val csv2: CsvIterator[("1", "2", "7"), (Int, Int, Int)] = CSV.resource(
      "simple_semicolon.csv",
      CsvOpts(HeaderOptions.FromRows(merge = 1, dropFirst = 1), TypeInferrer.FirstN(2), ';')
    )
    assertEquals(csv2.toSeq.length, 2)

  }

  test("column safety") {
    @nowarn def csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    assert(
      !compileErrors("csv.column[\"notcol\"]").isEmpty()
    )

    assert(
      compileErrors("""csv.toSeq.column["notcol1"]""").contains("""Column ("notcol1" : String) not found""")
    )
    assert(
      compileErrors("""csv.column["notcol1"]""").contains("""Column ("notcol1" : String) not found""")
    )
    assert(
      compileErrors("""csv.dropColumn["notcol1"]""").contains("""Column ("notcol1" : String) not found""")
    )
    assert(
      compileErrors("""csv.toSeq.dropColumn["notcol1"]""").contains("""Column ("notcol1" : String) not found""")
    )
    assert(
      compileErrors("""csv.toSeq.mapColumn["notcol1", Int]""").contains("""Column ("notcol1" : String) not found""")
    )
    assert(
      compileErrors("""csv.columns[("col1", "notCol")]""").contains("""Not all columns in (("col1" : String), ("notCol" : String))""")
    )

  }

  test("sample") {
    def csv = CSV.resource("titanic.csv")

    val sample = csv.sample(0.1)
    assertEqualsDouble(sample.length.toDouble, 89, 30)

    val sampleRand = csv.sample(0.1, true)
    assertEqualsDouble(sampleRand.length.toDouble, 89, 1)

    assertEquals(csv.sample(1).length, 891)

  }

  test("columns") {
    def csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    assert(
      !compileErrors("csv.columns[(\"notcol\")]").isEmpty()
    )

    def cols = csv.mapColumn["col1", Int](_.toInt)

    @nowarn def selectCols: Iterator[(col1: Int, col3: String)] = cols.columns[("col1", "col3")]

    assert(cols.toArray.head.col1 == 1)
    assert(cols.toArray.head.col3 == "7")
    assert(cols.toArray.last.col1 == 5)
    assert(cols.toArray.last.col3 == "9")

    @nowarn def numerics: Iterator[(col1: Int)] = cols.numericCols
    @nowarn def nonnumerics: Iterator[(col2: String, col3: String)] = cols.nonNumericCols

  }

  test("column order") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    // If this compiles, then the column order is preserved
    val selectCols: Iterator[(col3: String, col2: String, col1: String)] = csv.columns[("col3", "col2", "col1")]
    val ll = LazyList.from(selectCols)
    assert(ll.head.col1 == "1")
    assert(ll.head.col3 == "7")
    assert(ll.last.col3 == "9")

  }

  test("numeric and non numeric cols") {
    enum Gender:
      case Male, Female
    end Gender

    def titanic = CSV.resource("titanic.csv", TypeInferrer.StringType)
    def data = titanic
      .mapColumn["Sex", Gender]((x: String) => Gender.valueOf(x.capitalize))
      .dropColumn["PassengerId"]
      .mapColumn["Age", Option[Double]](_.toDoubleOption)
      .mapColumn["Survived", Boolean](_ == "1")
      .mapColumn["Pclass", Int](_.toInt)
      .mapColumn["SibSp", Int](_.toInt)
      .mapColumn["Parch", Int](_.toInt)
      .mapColumn["Fare", Double](_.toDouble)
      .toList

    @nowarn val numericol: Seq[(Pclass: Int, Age: Option[Double], SibSp: Int, Parch: Int, Fare: Double)] = data.numericCols

    @nowarn val nonNumericCols: Seq[(Survived: Boolean, Name: String, Sex: Gender, Ticket: String, Cabin: String, Embarked: String)] = data.nonNumericCols

  }

  test("column") {
    def csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    val column2 = csv.column["col2"]
    val col2 = column2.toArray
    assertEquals(col2.head, "2")
    assertEquals(col2.tail.head, "4")
    assertEquals(col2.last, "6")
  }

  test("drop column") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    val dropped = csv.dropColumn["col2"]
    val out = dropped.toArray
    assertEquals(out.head, ("1", "7"))
    assertEquals(out.tail.head, ("3", "8"))
    assertEquals(out.last, ("5", "9"))

  }

  test("easy print") {
    def csv = CSV.resource("simple.csv", TypeInferrer.StringType).toVector
    csv.ptbln

    val seq2 = Vector((1, 2), (3, 4))
    seq2.ptbl

  }

  test("Drop column, mapColumn, then select another") {
    def csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    def dropped = csv.dropColumn["col2"].mapColumn["col3", Int](_.toInt)

    val out = dropped.column["col3"].toArray
    assertEquals(out.head, 7)
    assertEquals(out.tail.head, 8)
    assertEquals(out.last, 9)

    val out2 = dropped.column["col1"].toArray
    assertEquals(out2.head, "1")
    assertEquals(out2.tail.head, "3")
    assertEquals(out2.last, "5")

  }

  test("wide load") {
    val wide22: CsvIterator[
      (
          "Column1",
          "Column2",
          "Column3",
          "Column4",
          "Column5",
          "Column6",
          "Column7",
          "Column8",
          "Column9",
          "Column10",
          "Column11",
          "Column12",
          "Column13",
          "Column14",
          "Column15",
          "Column16",
          "Column17",
          "Column18",
          "Column19",
          "Column20",
          "Column21",
          "Column22"
      ),
      (
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String,
          String
      )
    ] = CSV.resource("wide22.csv")
    val wide23 = CSV.resource("wide23.csv")
    val out: Array[String] = wide22.column["Column21"].toArray
    val out23: Array[String] = wide23.column["Column_21"].toArray

    assertEquals(out.mkString(","), "Data21_1,Data21_2,Data21_3,Data21_4,Data21_5,Data21_6,Data21_7,Data21_8,Data21_9,Data21_10")
    assertEquals(out23.mkString(","), "Data_21_Row1,Data_21_Row2,Data_21_Row3")

    // assertEquals(out.head, "Data_62_Row1")
    // assertEquals(out.tail.head, "Data_62_Row2")
    // assertEquals(out.tail.last, "Data_62_Row3")
  }

  test("reading data") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    assertEquals(csv.toArray.mkString(","), """(1,2,7),(3,4,8),(5,6,9)""")
  }

  test("add columns") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    val added = csv
      .addColumn["col3Times3", Int](_.col3.toInt * 3)
      .addColumn["col2Times10", Int](_.col2.toInt * 10)

    val again = added.addColumn["col2Times10Times2", Int](_.col2Times10 * 2)

    val out = again.toArray
    val check = out.map(_.col2Times10)
    val check2 = out.map(_.col2Times10Times2)
    val check3 = out.map(_.col3Times3)
    // val outCheck = again.map(_.col2Times10Times2).toArray

    assertEquals(check.head, 20)
    assertEquals(check2.head, 40)
    assertEquals(check3.head, 21)
    assertEquals(check.tail.head, 40)
    assertEquals(check.last, 60)

  }

  test("schema gen") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)
    val schema = csv.schemaGen
    assertNoDiff(
      schema,
      """object CsvSchema:
  type col1 = "col1"
  type col2 = "col2"
  type col3 = "col3"

import CsvSchema.*"""
    )
    object CsvSchema:
      type col1 = "col1"
      type col2 = "col2"
      type col3 = "col3"
    end CsvSchema

    import CsvSchema.*

    csv.column[col1].toArray // This should compile _and_ you get type completion
  }

  test("rename column") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    val renamed: Iterator[(col1: String, col2Renamed: String, col3: String)] = csv.renameColumn["col2", "col2Renamed"]
    val out = renamed.toArray
    assertEquals(out.head.col2Renamed, "2")
    assertEquals(out.tail.head.col2Renamed, "4")
    assertEquals(out.last.col2Renamed, "6")
  }

  test("force column type") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)

    val renamed: Iterator[(col1: String, col2Renamed: String, col3: String)] = csv.renameColumn["col2", "col2Renamed"].forceColumnType["col2Renamed", String]
    val out = renamed.toArray
    assertEquals(out.head.col2Renamed, "2")
    assertEquals(out.tail.head.col2Renamed, "4")
    assertEquals(out.last.col2Renamed, "6")
  }

  test("map column") {
    def csv = CSV.resource("simple.csv", TypeInferrer.StringType)

    def mapCol2 = csv.mapColumn["col2", Int]((s: String) => s.toInt)
    val result = mapCol2.toArray
    assertEquals(result.toArray.head.col2, 2)
    assertEquals(result.toArray.tail.head.col2, 4)
    assertEquals(result.toArray.last.col2, 6)

    def getCol = mapCol2.column["col2"]
    val result2 = getCol.toArray
    assertEquals(result2.head, 2)
    assertEquals(result2.tail.head, 4)
    assertEquals(result2.last, 6)

  }

  test("compose column operations 1") {

    /** If this compiles, then hopefully we have borked the typelevel bookkeeping
      */

    def csv = CSV.resource("simple.csv", TypeInferrer.StringType)

    def composed = csv
      .mapColumn["col2", Int]((s: String) => s.toInt)
      .addColumn["col2Times10", Int](_.col2 * 10)
      .dropColumn["col1"]
      .renameColumn["col3", "col3_renamed"]
      .mapColumn["col3_renamed", Int]((s: String) => s.toInt)
      .addColumn["argy", Double](_.col2Times10 * 2.0)
      .dropColumn["col2Times10"]
    composed.toArray.map(_.col3_renamed)
    composed.toArray.map(_.argy)

  }

  test("console print") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)
    assertNoDiff(
      csv.toArray.consoleFormatNt(),
      """| |col1|col2|col3|
|-|----|----|----|
|0|   1|   2|   7|
|1|   3|   4|   8|
|2|   5|   6|   9|
|-|----|----|----|""".trim()
    )

    val titanic = CSV.resource("titanic.csv").toArray
    assert(titanic.length == 891)

  }

  test("header indexes") {
    val csv: CsvIterator[("col1", "col2", "col3"), (String, String, String)] = CSV.resource("simple.csv", TypeInferrer.StringType)
    assertEquals(csv.headerIndex("col1"), 0)
    assertEquals(csv.headerIndex("col2"), 1)
    assertEquals(csv.headerIndex("col3"), 2)

    // csv.filter{ x =>
    //   println(x.col1)
    //   ???
    // }.toVector
  }

  test("missing values") {
    def csv = CSV.resource("missing.csv")

    val missing = csv.toList

    assertEquals(missing.length, 4)
    for r <- missing do assertEquals(r.toTuple.productArity, 3)
    end for
  }

  test("missing values wide") {
    def csv = CSV.resource("missing_wide.csv")

    val missing = csv.toList

    assertEquals(missing.length, 4)
    for r <- missing do assertEquals(r.toTuple.productArity, 22)
    end for

    val check = csv.filterNot(_.col18.isEmpty).toVector

    assertEquals(check.length, 2)

  }

  test("CSV.resource with AutoGenerated headers parses data_without_headers.csv correctly") {
    val csv = CSV.resource("data_without_headers.csv", CsvOpts(HeaderOptions.AutoGenerated, TypeInferrer.StringType))

    assertEquals(csv.headers, List("col_0", "col_1", "col_2"))

    val rows = csv.toArray

    assertEquals(rows.length, 3)

    assertEquals(rows(0).col_0, "Alice")
    assertEquals(rows(0).col_1, "25")
    assertEquals(rows(0).col_2, "Engineer")

    assertEquals(rows(1).col_0, "Bob")
    assertEquals(rows(1).col_1, "30")
    assertEquals(rows(1).col_2, "Designer")

    assertEquals(rows(2).col_0, "Charlie")
    assertEquals(rows(2).col_1, "22")
    assertEquals(rows(2).col_2, "Student")
  }

  test("CSV.resource with Manual headers parses data_without_headers.csv correctly") {
    val csv: CsvIterator[("name", "age", "profession"), (String, Int, String)] =
      CSV.resource("data_without_headers.csv", HeaderOptions.Manual("name", "age", "profession"), TypeInferrer.FirstRow)

    assertEquals(csv.headers, List("name", "age", "profession"))

    val rows = csv.toArray

    assertEquals(rows.length, 3)

    assertEquals(rows(0).name, "Alice")
    assertEquals(rows(0).age, 25)
    assertEquals(rows(0).profession, "Engineer")

    assertEquals(rows(1).name, "Bob")
    assertEquals(rows(1).age, 30)
    assertEquals(rows(1).profession, "Designer")

    assertEquals(rows(2).name, "Charlie")
    assertEquals(rows(2).age, 22)
    assertEquals(rows(2).profession, "Student")
  }

  test("resource should correctly drop initial lines and combine multi-line headers with FromRows(2, dropFirst = 1)") {
    val csvIterator = CSV.resource("multiline_headers_dropline.csv", CsvOpts(HeaderOptions.FromRows(merge = 2, dropFirst = 1), TypeInferrer.StringType))

    assertEquals(csvIterator.headers, List("Name First", "Age Years"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.`Name First`, "Alice")
    assertEquals(row1.`Age Years`, "30")
    assertEquals(row1.toTuple.toList, List("Alice", "30"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.`Name First`, "Bob")
    assertEquals(row2.`Age Years`, "24")
    assertEquals(row2.toTuple.toList, List("Bob", "24"))

    assert(!csvIterator.hasNext)
  }

  // test("url") {
  //   val csv = CSV.url("https://raw.githubusercontent.com/datasciencedojo/datasets/refs/heads/master/titanic.csv")
  // }
end CSVSuite
