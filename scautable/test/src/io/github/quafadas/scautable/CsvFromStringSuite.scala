// package io.github.quafadas.scautable

// import munit.FunSuite

// import scala.NamedTuple.withNames
// import scala.compiletime.testing.*
// import io.github.quafadas.scautable.HeaderOptions.*
// import io.github.quafadas.scautable.TypeInferrer.*
// import java.math.BigInteger

// class CsvFromStringSuite extends FunSuite:

//   test("fromString should correctly parse a simple CSV string") {
//     inline val csvContent = "colA,colB\n1,val1\n2,val2"
//     val csvIterator = CSV.fromString(csvContent, HeaderOptions.Default, TypeInferrer.fromTuple[(Int, String)])

//     assertEquals(csvIterator.headers, List("colA", "colB"))

//     assert(csvIterator.hasNext)
//     val row1 = csvIterator.next()
//     assertEquals(row1.colA, 1)
//     assertEquals(row1.colB, "val1")
//     assertEquals(row1.toTuple.toList, List(1, "val1"))

//     assert(csvIterator.hasNext)
//     val row2 = csvIterator.next()
//     assertEquals(row2.colA, 2)
//     assertEquals(row2.colB, "val2")
//     assertEquals(row2.toTuple.toList, List(2, "val2"))

//     assert(!csvIterator.hasNext)
//   }

//   test("BigInteger") {
//     inline given Decoder[BigInteger] with
//       def decode(str: String): Option[BigInteger] =
//         try
//           Some(new BigInteger(str))
//         catch
//           case _: NumberFormatException => None
//     inline val csvContent = "colA,colB\n123456789123456789123456789,val1\n987654321987654321987654321,val2"
//     val csvIterator = CSV.fromString(csvContent, HeaderOptions.Default, TypeInferrer.fromTuple[(BigInteger, String)])

//     assertEquals(csvIterator.headers, List("colA", "colB"))

//     assert(csvIterator.hasNext)
//     val row1 = csvIterator.next()
//     assertEquals(row1.colA, new BigInteger("123456789123456789123456789"))
//     assertEquals(row1.colB, "val1")
//     assertEquals(row1.toTuple.toList, List(new BigInteger("123456789123456789123456789"), "val1"))

//     assert(csvIterator.hasNext)
//     val row2 = csvIterator.next()
//     assertEquals(row2.colA, new BigInteger("987654321987654321987654321"))
//     assertEquals(row2.colB, "val2")
//     assertEquals(row2.toTuple.toList, List(new BigInteger("987654321987654321987654321"), "val2"))

//     assert(!csvIterator.hasNext)
//   }

//   // test("macro fails on empty CSV") {
//   //   val errors = typeCheckErrors("""
//   //     import io.github.quafadas.scautable.*
//   //     CSV.fromString[("colA", "colB")]("")
//   //   """)

//   //   assert(errors.exists(_.message.contains("Empty CSV content provided.")))
//   // }

//   test("fromString should handle duplicated headers by parsing correctly but warn at compile time") {
//     inline val csvContent = "colA,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11,col12,col13,col14,col15,col116,col17,col18,col19,col20,col21,col22,col23,col24,col25,colA,col2,col3,col4,col5,col6,col7,col8,col9,col10\n1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,1,2"
//     val csvIterator = CSV.fromString(csvContent, HeaderOptions.FromRows(1), TypeInferrer.fromTuple[(Int, String, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int,Int, Int, Int, Int, Int,Int, Int, Int, Int, Int)])

//     //assertEquals(csvIterator.headers, List("colA", "colB", "colC"))

//     assert(csvIterator.hasNext)
//     val row = csvIterator.next()
//     assertEquals(row.colA, 1) // Поверне перше "colA"
//     //assertEquals(row.toTuple.toList, List(1, 2, 3))

//     assert(!csvIterator.hasNext)
//   }

//     test("fromString should handle duplicated headers by parsing correctly but warn at compile time") {
//     inline val csvContent = "colA,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11,col12,col13,col14,col15,col116,col17,col18,col19,col20,col21,col22,col23,col24,col25,colA,col2,col3,col4,col5,col6,col7,col8,col9,col10\n1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,1,2"
//     val csvIterator = CSV.fromString(csvContent, HeaderOptions.FromRows(1), TypeInferrer.Auto)
//     //assertEquals(csvIterator.headers, List("colA", "colB", "colC"))

//     assert(csvIterator.hasNext)
//     val row = csvIterator.next()
//     assertEquals(row.colA, 1) // Поверне перше "colA"
//     //assertEquals(row.toTuple.toList, List(1, 2, 3))

//     assert(!csvIterator.hasNext)
//   }

//   test("2fromString should handle duplicated headers by parsing correctly but warn at compile time") {
//     inline val csvContent = "colA,colB,colC\n1,2,3"
//     val csvIterator = CSV.fromString(csvContent, HeaderOptions.FromRows(1), TypeInferrer.Auto)

//     assertEquals(csvIterator.headers, List("colA", "colB", "colC"))

//     assert(csvIterator.hasNext)
//     val row = csvIterator.next()
//     assertEquals(row.colA, 1) // Поверне перше "colA"
//     assertEquals(row.toTuple.toList, List(1, 2, 3))

//     assert(!csvIterator.hasNext)
//   }

//   // test("AutoGenerated should create headers based on column index") {
//   //   inline val csvContent = "1,2,3\n4,5,6"
//   //   val csvIterator = CSV.fromString[(String,String,String)](csvContent, HeaderOptions.AutoGenerated)

//   //   assertEquals(csvIterator.headers, List("col_0", "col_1", "col_2"))

//   //   assert(csvIterator.hasNext)
//   //   val row1 = csvIterator.next()
//   //   assertEquals(row1.col_0, "1")
//   //   assertEquals(row1.col_1, "2")
//   //   assertEquals(row1.col_2, "3")
//   //   assertEquals(row1.toTuple.toList, List("1", "2", "3"))

//   //   assert(csvIterator.hasNext)
//   //   val row2 = csvIterator.next()
//   //   assertEquals(row2.col_0, "4")
//   //   assertEquals(row2.col_1, "5")
//   //   assertEquals(row2.col_2, "6")
//   //   assertEquals(row2.toTuple.toList, List("4", "5", "6"))

//   //   assert(!csvIterator.hasNext)
//   // }

//   // test("H should use explicit headers and consume no initial rows") {
//   //   inline val csvContent = "1,2,3\n4,5,6"
//   //   val csvIterator = CSV.fromString[(String,String,String)](csvContent, HeaderOptions.Manual("headerA", "headerB", "headerC"))

//   //   assertEquals(csvIterator.headers, List("headerA", "headerB", "headerC"))

//   //   assert(csvIterator.hasNext)
//   //   val row1 = csvIterator.next()
//   //   assertEquals(row1.headerA, "1")
//   //   assertEquals(row1.headerB, "2")
//   //   assertEquals(row1.headerC, "3")
//   //   assertEquals(row1.toTuple.toList, List("1", "2", "3"))

//   //   assert(csvIterator.hasNext)
//   //   val row2 = csvIterator.next()
//   //   assertEquals(row2.headerA, "4")
//   //   assertEquals(row2.headerB, "5")
//   //   assertEquals(row2.headerC, "6")
//   //   assertEquals(row2.toTuple.toList, List("4", "5", "6"))

//   //   assert(!csvIterator.hasNext)
//   // }

//   // test("fromString should combine multi-line headers correctly with HeaderOptions.R(1)") {
//   //   inline val csvContent = "Name,Age\nFirst,Years\nAlice,30\nBob,24"

//   //   val csvIterator = CSV.fromString[(String,String)](csvContent, HeaderOptions.FromRows(2))

//   //   assertEquals(csvIterator.headers, List("Name First", "Age Years"))

//   //   assert(csvIterator.hasNext)
//   //   val row1 = csvIterator.next()
//   //   assertEquals(row1.`Name First`, "Alice")
//   //   assertEquals(row1.`Age Years`, "30")
//   //   assertEquals(row1.toTuple.toList, List("Alice", "30"))

//   //   assert(csvIterator.hasNext)
//   //   val row2 = csvIterator.next()
//   //   assertEquals(row2.`Name First`, "Bob")
//   //   assertEquals(row2.`Age Years`, "24")
//   //   assertEquals(row2.toTuple.toList, List("Bob", "24"))

//   //   assert(!csvIterator.hasNext)
//   // }

//   // test("fromString should correctly drop initial lines and combine multi-line headers with FromRows(2, dropFirst = 1)") {
//   //   inline val csvContent = "skip this line\nName,Age\nFirst,Years\nAlice,30\nBob,24"

//   //   val csvIterator = CSV.fromString[(String,String)](csvContent, HeaderOptions.FromRows(merge = 2, dropFirst = 1))

//   //   assertEquals(csvIterator.headers, List("Name First", "Age Years"))

//   //   assert(csvIterator.hasNext)
//   //   val row1 = csvIterator.next()
//   //   assertEquals(row1.`Name First`, "Alice")
//   //   assertEquals(row1.`Age Years`, "30")
//   //   assertEquals(row1.toTuple.toList, List("Alice", "30"))

//   //   assert(csvIterator.hasNext)
//   //   val row2 = csvIterator.next()
//   //   assertEquals(row2.`Name First`, "Bob")
//   //   assertEquals(row2.`Age Years`, "24")
//   //   assertEquals(row2.toTuple.toList, List("Bob", "24"))

//   //   assert(!csvIterator.hasNext)
//   // }

// end CsvFromStringSuite
