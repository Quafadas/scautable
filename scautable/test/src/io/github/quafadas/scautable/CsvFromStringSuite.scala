package io.github.quafadas.scautable

import java.math.BigInteger

import scala.compiletime.testing.*

import io.github.quafadas.scautable.HeaderOptions.*
import io.github.quafadas.table.TypeInferrer
import munit.FunSuite

class CsvFromStringSuite extends FunSuite:

  test("fromString should correctly parse a simple CSV string") {
    inline val csvContent = "colA,colB\n1,val1\n2,val2"
    val csvIterator = CSV.fromString(csvContent, HeaderOptions.Default, TypeInferrer.FromTuple[(Int, String)]())

    assertEquals(csvIterator.headers, List("colA", "colB"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.colA, 1)
    assertEquals(row1.colB, "val1")
    assertEquals(row1.toTuple.toList, List(1, "val1"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.colA, 2)
    assertEquals(row2.colB, "val2")
    assertEquals(row2.toTuple.toList, List(2, "val2"))

    assert(!csvIterator.hasNext)
  }

  test("BigInteger") {
    inline given Decoder[BigInteger] with
      def decode(str: String): Option[BigInteger] =
        try Some(new BigInteger(str))
        catch case _: NumberFormatException => None
    end given
    inline val csvContent = "colA,colB\n123456789123456789123456789,val1\n987654321987654321987654321,val2"
    val csvIterator = CSV.fromString(csvContent, HeaderOptions.Default, TypeInferrer.FromTuple[(BigInteger, String)]())

    assertEquals(csvIterator.headers, List("colA", "colB"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.colA, new BigInteger("123456789123456789123456789"))
    assertEquals(row1.colB, "val1")
    assertEquals(row1.toTuple.toList, List(new BigInteger("123456789123456789123456789"), "val1"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.colA, new BigInteger("987654321987654321987654321"))
    assertEquals(row2.colB, "val2")
    assertEquals(row2.toTuple.toList, List(new BigInteger("987654321987654321987654321"), "val2"))

    assert(!csvIterator.hasNext)
  }

  test("macro fails on empty CSV") {
    val errors = typeCheckErrors("""
      import io.github.quafadas.scautable.*
      CSV.fromString[("colA", "colB")]("")
    """)

    assert(errors.exists(_.message.contains("Empty CSV content provided.")))
  }

  test("fromString should handle duplicated headers by parsing correctly but warn at compile time") {
    inline val csvContent: String =
      "colA,col2,col3,col4,col5,col6,col7,col8,col9,col10,col11,col12,col13,col14,col15,col116,col17,col18,col19,col20,col21,col22,col23,col24,col25,colA,col2,col3,col4,col5,col6,col7,col8,col9,col10\n1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,1,2"
    val csvIterator = CSV.fromString(csvContent, HeaderOptions.FromRows(1), TypeInferrer.FirstRow)

    assert(csvIterator.hasNext)
    val row = csvIterator.next()
    assertEquals(row.colA, 1)

    assert(!csvIterator.hasNext)
  }

  test("2fromString should handle duplicated headers by parsing correctly but warn at compile time") {
    inline val csvContent = "colA,colB,colC\n1,2,3"
    val csvIterator = CSV.fromString(csvContent, HeaderOptions.FromRows(1), TypeInferrer.FirstRow)

    assertEquals(csvIterator.headers, List("colA", "colB", "colC"))

    assert(csvIterator.hasNext)
    val row = csvIterator.next()
    assertEquals(row.colA, 1)
    assertEquals(row.toTuple.toList, List(1, 2, 3))

    assert(!csvIterator.hasNext)
  }

  test("AutoGenerated should create headers based on column index") {
    inline val csvContent = "1,2,3\n4,5,6"
    val csvIterator = CSV.fromString[(String, String, String)](csvContent, CsvOpts(HeaderOptions.AutoGenerated, TypeInferrer.StringType))

    assertEquals(csvIterator.headers, List("col_0", "col_1", "col_2"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.col_0, "1")
    assertEquals(row1.col_1, "2")
    assertEquals(row1.col_2, "3")
    assertEquals(row1.toTuple.toList, List("1", "2", "3"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.col_0, "4")
    assertEquals(row2.col_1, "5")
    assertEquals(row2.col_2, "6")
    assertEquals(row2.toTuple.toList, List("4", "5", "6"))

    assert(!csvIterator.hasNext)
  }

  test("H should use explicit headers and consume no initial rows") {
    inline val csvContent = "1,2,3\n4,5,6"
    val csvIterator = CSV.fromString[(String, String, String)](csvContent, CsvOpts(HeaderOptions.Manual("headerA", "headerB", "headerC"), TypeInferrer.StringType))

    assertEquals(csvIterator.headers, List("headerA", "headerB", "headerC"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.headerA, "1")
    assertEquals(row1.headerB, "2")
    assertEquals(row1.headerC, "3")
    assertEquals(row1.toTuple.toList, List("1", "2", "3"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.headerA, "4")
    assertEquals(row2.headerB, "5")
    assertEquals(row2.headerC, "6")
    assertEquals(row2.toTuple.toList, List("4", "5", "6"))

    assert(!csvIterator.hasNext)
  }

  test("fromString should combine multi-line headers correctly with HeaderOptions.R(1)") {
    inline val csvContent = "Name,Age\nFirst,Years\nAlice,30\nBob,24"

    val csvIterator = CSV.fromString[(String, String)](csvContent, CsvOpts(HeaderOptions.FromRows(2), TypeInferrer.StringType))

    assertEquals(csvIterator.headers, List("Name First", "Age Years"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.`Name First`, "Alice")
    assertEquals(row1.`Age Years`, "30")
    assertEquals(row1.toTuple.toList, List("Alice", "30"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.`Name First`, "Bob")
    assertEquals(row2.`Age Years`, "24")
    assertEquals(row2.toTuple.toList, List("Bob", "24"))

    assert(!csvIterator.hasNext)
  }

  test("fromString should correctly drop initial lines and combine multi-line headers with FromRows(2, dropFirst = 1)") {
    inline val csvContent = "skip this line\nName,Age\nFirst,Years\nAlice,30\nBob,24"

    val csvIterator = CSV.fromString[(String, String)](csvContent, CsvOpts(HeaderOptions.FromRows(merge = 2, dropFirst = 1), TypeInferrer.StringType))

    assertEquals(csvIterator.headers, List("Name First", "Age Years"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.`Name First`, "Alice")
    assertEquals(row1.`Age Years`, "30")
    assertEquals(row1.toTuple.toList, List("Alice", "30"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.`Name First`, "Bob")
    assertEquals(row2.`Age Years`, "24")
    assertEquals(row2.toTuple.toList, List("Bob", "24"))

    assert(!csvIterator.hasNext)
  }

  test("AutoGenerated should create headers based on column index") {
    inline val csvContent = "1,true,3\n4,false,6"
    val csvIterator = CSV.fromString(csvContent, HeaderOptions.AutoGenerated, TypeInferrer.FromTuple[(Int, Boolean, Int)]())

    assertEquals(csvIterator.headers, List("col_0", "col_1", "col_2"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.col_0, 1)
    assertEquals(row1.col_1, true)
    assertEquals(row1.col_2, 3)
    assertEquals(row1.toTuple.toList, List(1, true, 3))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.col_0, 4)
    assertEquals(row2.col_1, false)
    assertEquals(row2.col_2, 6)
    assertEquals(row2.toTuple.toList, List(4, false, 6))

    assert(!csvIterator.hasNext)
  }

  test("TypeInferrer.FirstRow should detect Int, Long, Double, Boolean and String automatically") {
    inline val csvContent = "id,isActive,name\n1,true,Alice\n2,false,Bob"
    val csvIterator = CSV.fromString(csvContent, TypeInferrer.FirstRow)

    assertEquals(csvIterator.headers, List("id", "isActive", "name"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.id, 1)
    assertEquals(row1.isActive, true)
    assertEquals(row1.name, "Alice")
    assertEquals(row1.toTuple.toList, List(1, true, "Alice"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.id, 2)
    assertEquals(row2.isActive, false)
    assertEquals(row2.name, "Bob")
    assertEquals(row2.toTuple.toList, List(2, false, "Bob"))

    assert(!csvIterator.hasNext)
  }

  test("TypeInferrer.StringType should treat all values as Strings regardless of actual type") {
    inline val csvContent = "col1,col2,col3\n1,true,3.14\n42,false,0.99"
    val csvIterator = CSV.fromString(csvContent, TypeInferrer.StringType)

    assertEquals(csvIterator.headers, List("col1", "col2", "col3"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.col1, "1")
    assertEquals(row1.col2, "true")
    assertEquals(row1.col3, "3.14")
    assertEquals(row1.toTuple.toList, List("1", "true", "3.14"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.col1, "42")
    assertEquals(row2.col2, "false")
    assertEquals(row2.col3, "0.99")
    assertEquals(row2.toTuple.toList, List("42", "false", "0.99"))

    assert(!csvIterator.hasNext)
  }

  test("TypeInferrer.fromTuple should respect explicit tuple type definition") {
    inline val csvContent = "name,age,profession\nAlice,30,Engineer\nBob,24,Designer"
    val csvIterator = CSV.fromString(
      csvContent,
      TypeInferrer.FromTuple[(String, Int, String)]()
    )

    assertEquals(csvIterator.headers, List("name", "age", "profession"))

    assert(csvIterator.hasNext)
    val row1 = csvIterator.next()
    assertEquals(row1.name, "Alice")
    assertEquals(row1.age, 30)
    assertEquals(row1.profession, "Engineer")
    assertEquals(row1.toTuple.toList, List("Alice", 30, "Engineer"))

    assert(csvIterator.hasNext)
    val row2 = csvIterator.next()
    assertEquals(row2.name, "Bob")
    assertEquals(row2.age, 24)
    assertEquals(row2.profession, "Designer")
    assertEquals(row2.toTuple.toList, List("Bob", 24, "Designer"))

    assert(!csvIterator.hasNext)
  }

end CsvFromStringSuite
