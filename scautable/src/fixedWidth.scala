package io.github.quafadas.scautable

import scala.io.Source
import scala.quoted.*

import io.github.quafadas.scautable.ColumnTyped.*
import io.github.quafadas.table.TypeInferrer

object FixedWidth:

  /** Reads a fixed-width file present in java resources and returns a [[io.github.quafadas.scautable.FixedWidthIterator]].
    *
    * Column widths are automatically inferred by detecting 2+ consecutive padding characters as field separators.
    *
    * Example:
    * {{{
    *   val fw = FixedWidth.resource("file.txt")
    *   val fwCustom = FixedWidth.resource("file.txt", FixedWidthOpts(trimFields = false))
    * }}}
    */
  transparent inline def resource[T](inline path: String): Any =
    resource[T](path, FixedWidthOpts(HeaderOptions.FromRows(1, 0), TypeInferrer.FromAllRows, true, ' '))

  transparent inline def resource[T](inline path: String, inline opts: FixedWidthOpts) = ${ readFixedWidthResource('path, 'opts) }

  // Macro implementation
  private def readFixedWidthResource(pathExpr: Expr[String], optsExpr: Expr[FixedWidthOpts])(using Quotes) =
    import quotes.reflect.*

    val resourceName = pathExpr.valueOrAbort
    val resourcePath = this.getClass.getClassLoader.getResource(resourceName)
    if resourcePath == null then report.throwError(s"Resource not found: $resourceName")
    end if

    // Use the resolved path for compile-time analysis, but pass the original resource name for runtime
    readHeaderlineAsFixedWidth(resourcePath.getPath, resourceName, optsExpr)
  end readFixedWidthResource

  private def readHeaderlineAsFixedWidth(path: String, resourceName: String, optsExpr: Expr[FixedWidthOpts])(using Quotes): Expr[Any] =
    import quotes.reflect.*

    val headersExpr = extractHeaderOptions(optsExpr)
    val typeInferrerExpr = extractTypeInferrer(optsExpr)
    val paddingCharExpr = extractPaddingChar(optsExpr)
    val trimFieldsExpr = extractTrimFields(optsExpr)

    // Extract values for compile-time processing
    val headerOpts: HeaderOptions = headersExpr.valueOrAbort
    val paddingChar: Char = paddingCharExpr.valueOrAbort
    val trimFields: Boolean = trimFieldsExpr.valueOrAbort

    val source = Source.fromFile(path)
    try
      val lines = source.getLines().toList

      // Infer column widths from the appropriate line (header or first data line)
      val widthInferenceLine = headerOpts match
        case HeaderOptions.FromRows(merge, dropFirst) =>
          // Use the first header line for width inference
          lines.drop(dropFirst).headOption.getOrElse(throw new Exception("File is empty"))
        case HeaderOptions.Manual(_*) =>
          // Use the first data line for width inference
          lines.headOption.getOrElse(throw new Exception("File is empty"))
        case HeaderOptions.AutoGenerated =>
          // Use the first data line for width inference
          lines.headOption.getOrElse(throw new Exception("File is empty"))

      // Infer column widths once from the chosen line
      val columnWidths = FixedWidthParser.inferColumnWidths(widthInferenceLine, paddingChar)

      // Handle headers based on options
      val (headers, dataLines) = headerOpts match
        case HeaderOptions.FromRows(1, 0) =>
          // First line is headers (Default case)
          val headerLine = lines.headOption.getOrElse(throw new Exception("File is empty"))
          // Always trim headers regardless of trimFields setting (needed for valid identifiers)
          val parsedHeaders = FixedWidthParser.parseLineWithWidths(headerLine, columnWidths, trimFields = true)
          (parsedHeaders, lines.tail)

        case HeaderOptions.FromRows(merge, dropFirst) =>
          // Skip dropFirst lines, then merge 'merge' lines as headers
          val headerLines = lines.drop(dropFirst).take(merge)
          if headerLines.length < merge then throw new Exception(s"File has fewer than ${dropFirst + merge} lines")
          end if
          // For simplicity, just use the first header line
          // Always trim headers regardless of trimFields setting (needed for valid identifiers)
          val parsedHeaders = FixedWidthParser.parseLineWithWidths(headerLines.head, columnWidths, trimFields = true)
          (parsedHeaders, lines.drop(dropFirst + merge))

        case HeaderOptions.Manual(names*) =>
          // Use provided names
          (names.toList, lines)

        case HeaderOptions.AutoGenerated =>
          // Auto-generate column names based on number of columns
          val generatedHeaders = (0 until columnWidths.length).map(i => s"col_$i").toList
          (generatedHeaders, lines)  // Don't skip any lines - all lines are data

      if headers.length != headers.distinct.length then report.info("Possible duplicated headers detected.")
      end if

      val headerTupleExpr = Expr.ofTupleFromSeq(headers.map(Expr(_)))
      val columnWidthsExpr = Expr(columnWidths)

      def constructWithTypes[Hdrs <: Tuple: Type, Data <: Tuple: Type]: Expr[FixedWidthIterator[Hdrs, Data]] =
        val resourceNameExpr = Expr(resourceName)
        val headersSeqExpr = Expr(headers)
        '{
          // Resolve resource at runtime in the correct classloader
          val resourceUrl = this.getClass.getClassLoader.getResource($resourceNameExpr)
          if resourceUrl == null then throw new java.io.FileNotFoundException(s"Resource not found: ${$resourceNameExpr}")
          end if
          val source = Source.fromFile(resourceUrl.getPath)
          val lines = source.getLines()
          // Skip header lines based on options
          val iterator = ${
            headerOpts match
              case HeaderOptions.FromRows(1, 0) =>
                '{ lines.drop(1) } // Skip first line (header)
              case HeaderOptions.FromRows(merge, dropFirst) =>
                val skipExpr = Expr(merge + dropFirst)
                '{ lines.drop($skipExpr) } // Skip dropFirst + merge lines
              case HeaderOptions.Manual(_*) =>
                '{ lines } // Don't skip any lines
              case HeaderOptions.AutoGenerated =>
                '{ lines } // Don't skip any lines
          }
          new FixedWidthIterator[Hdrs, Data](iterator, $headersSeqExpr, $columnWidthsExpr, $paddingCharExpr, $trimFieldsExpr)
        }
      end constructWithTypes

      headerTupleExpr match
        case '{ $tup: hdrs } =>
          typeInferrerExpr match

            case '{ TypeInferrer.FromTuple[t]() } =>
              constructWithTypes[hdrs & Tuple, t & Tuple]

            case '{ TypeInferrer.StringType } =>
              constructWithTypes[hdrs & Tuple, StringyTuple[hdrs & Tuple] & Tuple]

            case '{ TypeInferrer.FirstRow } =>
              // Parse rows using fixed-width parser and infer types
              val parsedRows = dataLines.take(1).map(line => FixedWidthParser.parseLineWithWidths(line, columnWidths, trimFields))
              if parsedRows.isEmpty then report.throwError("No data rows available for type inference")
              end if
              val columns = parsedRows.transpose
              val elementTypesRepr: List[TypeRepr] = columns.map { columnValues =>
                InferrerOps.inferMostGeneralType(columnValues, preferIntToBoolean = true)
              }
              val tupleType: TypeRepr = elementTypesRepr.foldRight(TypeRepr.of[EmptyTuple]) { (tpe, acc) =>
                TypeRepr.of[*:].appliedTo(List(tpe, acc))
              }
              tupleType.asType match
                case '[v] =>
                  constructWithTypes[hdrs & Tuple, v & Tuple]
              end match

            case '{ TypeInferrer.FirstN(${ Expr(n) }) } =>
              val parsedRows = dataLines.take(n).map(line => FixedWidthParser.parseLineWithWidths(line, columnWidths, trimFields))
              if parsedRows.isEmpty then report.throwError("No data rows available for type inference")
              end if
              val columns = parsedRows.transpose
              val elementTypesRepr: List[TypeRepr] = columns.map { columnValues =>
                InferrerOps.inferMostGeneralType(columnValues, preferIntToBoolean = true)
              }
              val tupleType: TypeRepr = elementTypesRepr.foldRight(TypeRepr.of[EmptyTuple]) { (tpe, acc) =>
                TypeRepr.of[*:].appliedTo(List(tpe, acc))
              }
              tupleType.asType match
                case '[v] =>
                  constructWithTypes[hdrs & Tuple, v & Tuple]
              end match

            case '{ TypeInferrer.FromAllRows } =>
              val parsedRows = dataLines.map(line => FixedWidthParser.parseLineWithWidths(line, columnWidths, trimFields))
              if parsedRows.isEmpty then report.throwError("No data rows available for type inference")
              end if
              val columns = parsedRows.transpose
              val elementTypesRepr: List[TypeRepr] = columns.map { columnValues =>
                InferrerOps.inferMostGeneralType(columnValues, preferIntToBoolean = false)
              }
              val tupleType: TypeRepr = elementTypesRepr.foldRight(TypeRepr.of[EmptyTuple]) { (tpe, acc) =>
                TypeRepr.of[*:].appliedTo(List(tpe, acc))
              }
              tupleType.asType match
                case '[v] =>
                  constructWithTypes[hdrs & Tuple, v & Tuple]
              end match

        case _ =>
          report.throwError("Could not infer literal header tuple.")
      end match

    finally source.close()
    end try
  end readHeaderlineAsFixedWidth

  // Helper methods to extract fields from FixedWidthOpts
  private def extractHeaderOptions(optsExpr: Expr[FixedWidthOpts])(using Quotes): Expr[HeaderOptions] =
    import quotes.reflect.*
    optsExpr.asTerm match
      case Inlined(_, _, Apply(_, args)) if args.nonEmpty =>
        // Extract first argument (headerOptions)
        args.head match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            '{ HeaderOptions.Default }  // Use default value
          case term =>
            term.asExprOf[HeaderOptions]
      case Apply(_, args) if args.nonEmpty =>
        // Extract first argument (headerOptions) - non-inlined case
        args.head match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            '{ HeaderOptions.Default }  // Use default value
          case term =>
            term.asExprOf[HeaderOptions]
      case _ =>
        '{ HeaderOptions.Default }

  private def extractTypeInferrer(optsExpr: Expr[FixedWidthOpts])(using Quotes): Expr[TypeInferrer] =
    import quotes.reflect.*
    optsExpr.asTerm match
      case Inlined(_, _, Apply(_, args)) if args.length >= 2 =>
        // Extract second argument (typeInferrer)
        args(1) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            '{ TypeInferrer.FromAllRows }  // Use default value
          case term =>
            term.asExprOf[TypeInferrer]
      case Apply(_, args) if args.length >= 2 =>
        // Extract second argument (typeInferrer) - non-inlined case
        args(1) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            '{ TypeInferrer.FromAllRows }  // Use default value
          case term =>
            term.asExprOf[TypeInferrer]
      case _ =>
        '{ TypeInferrer.FromAllRows }

  private def extractTrimFields(optsExpr: Expr[FixedWidthOpts])(using Quotes): Expr[Boolean] =
    import quotes.reflect.*
    optsExpr.asTerm match
      case Inlined(_, _, Apply(_, args)) if args.length >= 3 =>
        // Extract third argument (trimFields)
        args(2) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            Expr(true)  // Use default value
          case term =>
            term.asExprOf[Boolean]
      case Apply(_, args) if args.length >= 3 =>
        // Extract third argument (trimFields) - non-inlined case
        args(2) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            Expr(true)  // Use default value
          case term =>
            term.asExprOf[Boolean]
      case _ =>
        Expr(true)

  private def extractPaddingChar(optsExpr: Expr[FixedWidthOpts])(using Quotes): Expr[Char] =
    import quotes.reflect.*
    optsExpr.asTerm match
      case Inlined(_, _, Apply(_, args)) if args.length >= 4 =>
        // Extract fourth argument (paddingChar)
        // Check if it's a default parameter reference
        args(3) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            Expr(' ')  // Use default value
          case term =>
            term.asExprOf[Char]
      case Apply(_, args) if args.length >= 4 =>
        // Extract fourth argument (paddingChar) - non-inlined case
        args(3) match
          case Select(_, name) if name.startsWith("$lessinit$greater$default$") =>
            Expr(' ')  // Use default value
          case term =>
            term.asExprOf[Char]
      case _ =>
        Expr(' ')

end FixedWidth
