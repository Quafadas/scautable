package build.scautable

import $ivy.`com.lihaoyi::mill-contrib-buildinfo:`
import mill.contrib.buildinfo.BuildInfo

import mill._
import mill.scalalib._
import mill.scalalib.publish._
import mill.scalajslib._
import mill.scalajslib.api._
import build.Config

object `package` extends RootModule {

  trait SharedModule extends build.Common with PlatformScalaModule   

  trait SharedTest extends SharedModule with TestModule.Munit {
    override def ivyDeps = super.ivyDeps() ++
      Agg(
        ivy"org.scalameta::munit::1.1.1"
      )
  }

  object js extends SharedModule with build.CommonJS with build.PublishModule

  object test extends Module {    
    object js extends SharedTest with build.CommonJS {
      override def moduleDeps: Seq[JavaModule]  = Seq(build.scautable.js)
    }

    object jvm extends SharedTest with BuildInfo {
      override def moduleDeps = Seq(build.scautable.jvm)
      def buildInfoPackageName: String = "io.github.quafadas.scautable"
      override def generatedSources: T[Seq[PathRef]] = T{
        val resourceDir = resources().map(_.path).zipWithIndex.map{case (str, i) => s"""final val resourceDir$i = \"\"\"$str${java.io.File.separator}\"\"\""""  }.mkString("\n\t")
        val platformPathSeperator = s"""\n\tfinal val pathSep = "${java.io.File.separator}""""
        val fileName = "BuildInfo.scala"
        val code = s"""package io.github.quafadas.scautable

/**
Resources are not available at compile time. This is a workaround to get the path to the resource directory, (allowing unit testing of a macro based on a local file).
*/

object Generated {$resourceDir$platformPathSeperator
}
"""
    val dest = T.ctx().dest / "BuildInfo.scala"
    os.write(dest , code)
    Seq(PathRef(dest))

      }      
    }
  }
  
  object jvm extends SharedModule with ScalaModule with build.PublishModule {
    override def ivyDeps= super.ivyDeps() ++ Agg(
      ivy"org.apache.poi:poi:5.4.1",
      ivy"org.apache.poi:poi-ooxml:5.4.1",
    )
  }
}